# **2-05 리포지터리로 데이터베이스 관리하기**

- 데이터를 CRUD하려면 DB와 연동하는 JPA 리포지터리 필요

## 리포지터리 생성하기

- 리포지터리 = Entity를 통해 생성된 DB 테이블들의 데이터를 CRUD 할 수 있게 도와주는 인터페이스(CRUD할 수 있게 해주는 메서드들(findAll, save, …)을 제공한다.)

```java
public interface ReviewCommentRepository extends JpaRepository<ReviewComment, Long> {
```

- ReviewCommentRepository 인터페이스를 리포지터리로 만들기 위해 JpaRepository 인터페이스를 상속한다.
- 이제, ReviewCommentRepository로 ReviewComment 테이블에 데이터를 CRUD 할 수 있음!

## JUnit

- 리포지터리를 이용하여 데이터를 저장하려면 질문을 등록하는 화면+컨트롤러+서비스 파일 등이 필요함. But, JUnit을 통해 이러한 프로세스 없이 리포지터리만 개별적으로 실행+테스트 해볼 수 있음!
- JUnit: 테스트 코드를 작성하고 실행할 때 사용하는 바자의 테스트 프레임워크

```java
@SpringBootTest
class SpaceRepositoryTest {

    @Autowired
    SpaceRepository spaceRepository;

    @Test
    void testJpa(){
        Space space = new Space();
        space.builder()
                .name("test1")
                .address("address1")
                .description("description1")
                .build();
        spaceRepository.save(space);
    }
}

```

- `@SpringBootTest`: 해당 클래스가 스프링 부트의 테스트 클래스임을 알림

- `@Autowired` : 해당 변수에 객체를 자동으로 만들어 주입함. = 의존성 주입
    - 이러한 의존성 주입 방식은 `@Autowired` 외에도 setter, 생성자를 사용하는 방식 등이 있다. 이 중에서도 순환 참조 문제때문에 생성자를 통한 객체 주입 방식을 권장한다.
    - But, 테스트 코드의 경우 JUnit이 생성자를 통한 객체 주입을 지원하지 않아서 @Autowired를 사용한다.

- *순환 참조 문제*는 **A 객체가 B 객체를 필요로 하고, 동시에 B 객체도 A 객체를 필요로 하는 상황**에서 발생합니다.
    
    ### 🔄 순환 참조 예시
    
    ```java
    @Component
    public class A {
        private final B b;
    
        @Autowired
        public A(B b) {
            this.b = b;
        }
    }
    
    @Component
    public class B {
        private final A a;
    
        @Autowired
        public B(A a) {
            this.a = a;
        }
    }
    
    ```
    
    - `A`는 생성자로 `B`를 필요로 하고,
    - `B`는 생성자로 `A`를 필요로 합니다.
    
    스프링이 빈을 만들 때,
    
    1. `A`를 만들려고 보니 `B`가 필요함
    2. `B`를 만들려고 보니 `A`가 필요함
    3. 다시 `A`를 만들려고 보니… 무한 반복 😵
    
    → 결국 **BeanCurrentlyInCreationException** 같은 오류가 발생
    
    ### ⚖️ 주입 방식과 순환 참조
    
    - **생성자 주입**: 객체가 만들어질 때 반드시 의존성이 필요하므로, 순환 참조가 있으면 **바로 예외** 발생 → 문제를 조기에 발견 가능 ✅
    - **필드 주입(@Autowired) / Setter 주입**: 객체를 만들고 나중에 의존성을 채워 넣기 때문에, 스프링이 임시 프록시를 넣어 순환 참조를 "어느 정도" 처리할 수 있음. 하지만 이는 **안정적이지 않고 숨은 버그**가 될 수 있어 권장되지 않음.

```java
@SpringBootTest

    @Autowired
    SpaceRepository spaceRepository;

    @AfterEach
    void tearDown() {
        spaceRepository.deleteAll();
    }

    @Test
    @DisplayName("findAll() 테스트")
    void testJpa1(){
        Space space1 = new Space();
        space1.builder()
                .name("test1")
                .spaceCategory(SpaceCategory.CAFE)
                .address("address1")
                .description("description1")
                .build();
        spaceRepository.save(space1);

        Space space2 = new Space();
        space2.builder()
                .name("test2")
                .spaceCategory(SpaceCategory.CAFE)
                .address("address2")
                .description("description2")
                .build();
        spaceRepository.save(space2);

        List<Space> all = spaceRepository.findAll();
        assertEquals(2, all.size());
    }

    @Test
    @DisplayName("findById() 테스트")
    void testJpa2(){
        Space space1 = new Space();
        space1.builder()
                .name("test1")
                .spaceCategory(SpaceCategory.CAFE)
                .address("address1")
                .description("description1")
                .build();
        spaceRepository.save(space1);

        Optional<Space> os = spaceRepository.findById(space1.getId());
        if(os.isPresent()){
            assertEquals(space1.getName(), os.get().getName());
        }
    }

    @Test
    @DisplayName("findByName() 테스트")
    void testJpa3(){
        Space space1 = new Space();
        space1.builder()
                .name("test1")
                .spaceCategory(SpaceCategory.CAFE)
                .address("address1")
                .description("description1")
                .build();
        spaceRepository.save(space1);

        Optional<Space> os = spaceRepository.findByName(space1.getName());
        if(os.isPresent()){
            assertEquals(space1.getId(), os.get().getId());
        }
    }

    @Test
    @DisplayName("findByNameAndSpaceCategory() 테스트")
    void testJpa4(){
        Space space1 = new Space();
        space1.builder()
                .name("test1")
                .spaceCategory(SpaceCategory.CAFE)
                .address("address1")
                .description("description1")
                .build();
        spaceRepository.save(space1);

        Optional<Space> os = spaceRepository.findByNameAndSpaceCategory(space1.getName(), space1.getSpaceCategory());
        if(os.isPresent()){
            assertEquals(space1.getId(), os.get().getId());
        }
    }

}
```

- `assertEquals(기댓값, 실젯값)` , `assertTrue()`
- `Optional` : null값을 유연하게 처리하기 위한 클래스. `isPresent()` 메서드로 값이 존재하는지 확인할 수 있음.
- 리포지터리의 메서드명은 데이터를 조회하는 쿼리문의 where 조건을 결정하는 역할을 한다.

## Transactional이 필요한 시점

```java
@SpringBootTest
class SbbApplicationTests {

    @Autowired
    private QuestionRepository questionRepository;

    @Test
    @Transactional // <- 추가해야지 해결 가능
    void testJpa() {
        Optional<Question> oq = questionRepository.findById(2);
        assertTrue(oq.isPresent());
        Question q = oq.get();

        List<Answer> answerList = q.getAnswerList();

        assertEquals(1, answerList.size());
        assertEquals("네 자동으로 생성됩니다.", answerList.get(0).getContent());
    }
}

```

- 위의 코드를 실행하면, LazyInitializationException이 발생한다.
    
    ⇒ `findById` 메서드로 객체를 조회하고 나면 DB 세션(스프링부트&DB 사이의 연결)이 끊어지기 때문에 `q.getAnswerList()`메서드를 호출할 때 에러 발생.
    
- Lazy(지연) 방식: answer 리스트 데이터를 필요한 시점에 가져오는 방식
- Eager(즉시) 방식: q객체를 조회할 때 미리 answer 리스트를 모두 가져오는 방식
- → @OneToManyt, @ManyToOne 등에 옵션으로 설정할 수 있음. fetch=FetchType.LAZY 또는 fetch=FetchType.EAGER
- [참고] JPA에서 `FetchType`의 기본값은 연관 관계의 종류에 따라 다름. `@OneToOne` 및 `@ManyToOne` 관계에서는 `FetchType.EAGER` (즉시 로딩)이 기본값이며, `@OneToMany` 및 `@ManyToMany` 관계에서는 `FetchType.LAZY` (지연 로딩)이 기본값임.
- 하지만, 실제 서버에서 JPA 프로그램들을 실행할 때는 DB세션이 종료되지 않아서 이러한 에러가 발생하지 않음. 테스트 코드를 수행할 때만 발생하는 문제임! 따라서, FetchType.EAGER을 설정하기보다는 `@Transactional` 을 붙여서 해당 테스트 코드 메서드가 종료될 때까지 DB 세션을 유지하게 하면 됨!


